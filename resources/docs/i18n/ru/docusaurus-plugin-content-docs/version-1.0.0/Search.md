---
title: 'Поиск'
---

Каждый элемент в системе обладает некоторой информацией, которая позволяет однозначно его [идентифицировать](Element_identification.md) среди других элементов этой системы. Впрочем делать это, предоставляя всю информацию об элементе в каждом месте его использования, достаточно трудозатратно, поэтому в платформе существует специальный алгоритм *поиска*, который позволяет найти нужный элемент обладая лишь частью информации о нем (например только коротким [именем](Naming.md) и [модулем](Modules.md), в котором используется искомый элемент).

В общем случае, алгоритм поиска состоит из одного или нескольких *шагов поиска. *Шаги выполняются друг за другом, таким образом, что если на первом шаге искомый элемент не был найден, выполняется второй шаг, затем следующий и так далее пока либо не будет найден искомый элемент, либо закончатся шаги (в последнем случае, платформа выдаст ошибку, что элемент не найден).

Каждый шаг поиска, в свою очередь, состоит из нескольких подшагов:

-   *Условия шага* - множество условий, каждое из которых должно быть выполнено, чтобы шаг вообще имело смысл выполнять. Эта проверка выполняется еще до того, как начат просмотр хоть каких-то элементов системы и целиком зависит от контекста обращения.
-   *Условия отбора* - множество условий, каждое из которых должно быть выполнено для каждого элемента, который претендует на то, чтобы быть искомым элементом. На этом шаге элементы не зависят друг от друга, а результатом выполнения этого шага является отобранное *множество кандидатов, *на то, чтобы быть искомым элементом.
-   *Операции выбора* - список операций, каждая из которых фильтрует множество кандидатов, в зависимости от того, какие из кандидатов в этом множестве потенциально "лучше" (то есть с большей вероятностью) подходят на роль искомого элемента.

Если после выполнения последней операции выбора остался:

-   ровно один элемент - он и считается искомым. 
-   больше одного элемента - платформа выдаст ошибку, что не возможно однозначно определить искомый элемент
-   ни одного элемента - платформа либо перейдет на следующий шаг поиска (если он есть), либо выдаст ошибку что элемент не найден.

Ниже приведены шаги, условия и операции алгоритма поиска, в зависимости от типа искомого элемента:

|Тип элемента|Шаг поиска|Условия шага|Условия отбора|Операции выбора|
|---|---|---|---|---|
|[Модули](Modules.md)|<br /><br/>|<p><br /><br/></p>|<ul><br/><li>Совпадает имя[...](#name)</li><br/></ul>|<br /><br/>|
|[Формы](Forms.md), [Классы](Static_objects.md), [Элементы навигатора](Navigator.md), [Группы свойств и действий](Groups_of_properties_and_actions.md), [Таблицы](Tables.md), [Дизайн навигатора](Navigator_design.md)|<br /><br/>|<p><br /><br/></p>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится в зависимом модуле[...](#module)</li><br/><li>Находится в заданном пространстве имен (если задано явно)[...](#namespace)</li><br/></ul>|<ul><br/><li>Выбор приоритетного пространства имен (если пространство имен не задано явно)[...](#priority)</li><br/></ul>|
|<p>[Метакоды](Metaprogramming.md)</p>|<br /><br/>|<p><br /><br/></p>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится в зависимом модуле[...](#module)</li><br/><li>Находится в заданном пространстве имен (если задано явно)[...](#namespace)</li><br/><li>Количество параметров совпадает[...](#metacode)</li><br/></ul>|<ul><br/><li>Выбор приоритетного пространства имен (если пространство имен не задано явно)[...](#priority)</li><br/></ul>|
|[Свойства](Properties.md), [Действия](Actions.md)|Локальные|<ul><br/><li>Поиск свойства внутри действия[...](#locals)</li><br/><li>Пространство имен не задано явно[...](#nonamespace)</li><br/></ul>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится сверху по стеку[...](#stack)</li><br/><li>Подходит по классам параметров[...](#direct)</li><br/></ul>|<ul><br/><li>Выбор более конкретных классов параметров[...](#concrete)</li><br/></ul>|
|Локальные общие|<ul><br/><li>Поиск свойства внутри действия[...](#locals)</li><br/><li>Пространство имен не задано явно[...](#nonamespace)</li><br/></ul>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится сверху по стеку[...](#stack)</li><br/><li>Пересекается по классам параметров[...](#indirect)</li><br/></ul>|<p><br /><br/></p><br/><p><br /><br/></p>|
|Глобальные|<br /><br/>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится в зависимом модуле[...](#module)</li><br/><li>Находится в заданном пространстве имен (если задано явно)[...](#namespace)</li><br/><li>Подходит по классам параметров[...](#direct)</li><br/><li>Свойство абстрактное (если идет поиск абстрактного свойства)[...](#abstract)</li><br/></ul>|<ul><br/><li>Выбор приоритетного пространства имен (если пространство имен не задано явно)[...](#priority)</li><br/><li>Выбор не совпадающих классов параметров (если идет поиск абстрактного свойства)[...](#notequals)</li><br/><li>Выбор более конкретных классов параметров[...](#concrete)</li><br/></ul>|
|Глобальные общие|<ul><br/><li>Не поиск абстрактного свойства[...](#notabstract)</li><br/></ul>|<ul><br/><li>Совпадает имя[...](#name)</li><br/><li>Находится в зависимом модуле[...](#module)</li><br/><li>Находится в заданном пространстве имен (если задано явно)[...](#namespace)</li><br/><li>Пересекается по классам параметров[...](#indirect)</li><br/></ul>|<ul><br/><li>Выбор приоритетного пространства имен (если пространство имен не задано явно)[...](#priority)</li><br/></ul>|

Описание шагов, условий и операций алгоритма поиска:

## Совпадает имя {#name}

Имя кандидата совпадает с именем поиска (всегда должно задаваться при поиске явно). Сравнение регистро-зависимое (то есть aA != AA).

## Находится в зависимом модуле {#module}

Модуль кандидата [зависит](Modules.md#depends) от модуля, в котором осуществляется поиск.

## Находится в заданном пространстве имен (если задано явно) {#namespace}

[Пространство имен](Naming.md#namespace) кандидата совпадает с пространством имен поиска (если это пространство имен задано явно).

## Выбор приоритетного пространства имен (если пространство имен не задано явно) {#priority}

Если в текущем множестве есть кандидаты из пространства имен, в котором осуществляется поиск - все остальные кандидаты удаляются из множества кандидатов, и операция выбора завершается. Если нет, аналогичное действие повторяется для *приоритетных* пространств имен, модуля, в котором осуществляется поиск (в порядке задания этих приоритетных пространств). Если и для них ничего не найдено, множество кандидатов остается неизменным.

## Количество параметров совпадает {#metacode}

Количество параметров кандидата совпадает с количеством параметров обращения.

## Поиск свойства внутри действия {#locals}

Данный шаг выполняется только, для поиска свойства, причем если этот поиск идет внутри некоторого действия (а не, например, в объявлении формы).

### Пространство имен не задано явно {#nonamespace}

Данный шаг выполняется только, для если пространство имен поиска не задано.

## Находится сверху по стеку {#stack}

Кандидат является [локальным свойством](Data_properties_DATA_.md#local) и :

-   объявляется внутри оператора [последовательности](Sequence_..._.md), который выполняет действие, которое обращается к искомому элементу.
-   объявляется раньше, чем действие, которое непосредственно обращается к искомому элементу.

## Подходит по классам параметров {#direct}

[Классы параметров обращения](#call-broken) [подходят](#directclasses-broken) [классам параметров кандидата](#decl-broken) или классы параметров обращения неизвестны.

## Пересекается по классам параметров {#indirect}

[Классы параметров обращения](#call-broken) [пересекаются](#indirectclasses-broken) с [классами параметров кандидата](#decl-broken).

## Выбор более конкретных классов параметров {#concrete}

Если в множестве кандидатов есть свойства **A** и **B**, такие что классы параметров **A** подходят классам параметров **B**, то свойство **B** удаляется из множества кандидатов.

## Не поиск абстрактного свойства {#notabstract}

Данный шаг не выполняется, если идет поиск свойства (действия) в операторе [расширения](Property_extension.md) свойства (действия), при чем идет поиск именно расширяемого (абстрактного) свойства (при поиске свойств в реализации используется общий механизм поиска).

## Свойство абстрактное (если идет поиск абстрактного свойства) {#abstract}

Кандидат является [абстрактным](Property_extension.md) свойством (действием).

## Выбор не совпадающих классов параметров (если идет поиск абстрактного свойства) {#notequals}

Если :

-   идет поиск абстрактного свойства (действия)
-   классы параметров обращения не заданы явно
-   среди множества кандидатов есть свойства (действия), классы параметров которых совпадают с классами параметров обращения
-   среди множества кандидатов есть свойства (действия), классы параметров которых не совпадают с классами параметров обращения

То : из множества кандидатов удаляются свойства (действия) из третьего пункта (то есть, у которых классы параметров совпадают с классами параметров обращения)

#### Дополнительные операции для поиска свойств / действий

*Соответствие классов параметров*

Будем говорить, что классы параметров (A1,..., An) *подходят *классам параметров (B1, ..., Bm), если:

-   n=m, то есть количество параметров совпадает
-   для каждого параметра **i**, одно из следующих верно:
    -   Ai неизвестно (равно **?**)
    -   Bi неизвестно (равно **?**)
    -   Ai [наследуется](Static_objects.md#inheritance) от Bi (а точнее множество классов-потомков Bi включает в себя множество классов-потомков Ai)

*Пересечение классов параметров*

Будем говорить, что классы параметров (A1,..., An) *пересекаются *с классами параметров (B1, ..., Bm), если:

-   n=m, то есть количество параметров совпадает
-   для каждого параметра **i**, одно из следующих верно:
    -   Ai неизвестно (равно **?**)
    -   Bi неизвестно (равно **?**)
    -   Ai и Bi имеют общего потомка (а точнее множество классов-потомков Bi пересекается с множеством классов-потомков Ai)

*Определение классов параметров обращения*

При обращении к свойству (действию), если классы параметров не заданы явно, платформа пытается самостоятельно определить их из контекста обращения. Ниже приведен список (неполный) возможных контекстов, и как платформа определяет классы параметров обращения в этих случаях:

|Контекст|Классы параметров обращения|
|---|---|
|Композиция / Вызов|Классы значений свойств-аргументов|
|Использование на форме|Классы объектов подставляемых на вход искомому свойству / действию|
|Добавления действия в навигатор|Пустой список|
|Результаты ввода, внешнего обращения|Пустой список|
|Простое разбиение|Классы значений свойств-групп (блок <strong>BY</strong>)|
|Вложенные локальные свойства в операторах работы с сессией|Неизвестно|
|Импорт данных|Если импортируется список значений (<strong>LIST</strong>), пустой список, иначе список из одного элемента <strong>INTEGER</strong>|

*Определение классов параметров свойства (действия)*

Если классы параметров свойства (действия) не заданы явно, платформа пытается самостоятельно определить их из реализации этого свойства (действия). Ниже приведен список (неполный) возможных реализаций, и как платформа определяет классы параметров свойства (действия) в этих случаях:

|Контекст|Классы параметров обращения|
|---|---|
|Выражения|Классы параметров (в порядке их использования)|
|Первичное, Абстрактное|Классы задаются явно в самом операторе|
|Формула, Внутренний вызов|Могут задаваться явно в самом операторе, если не заданы, все классы параметров считаются неизвестными (<strong>?</strong>), их количество определяется спецификой конкретного оператора|
|Группировка|Классы значений свойств-групп (блок <strong>BY</strong>)|
|Операции с группами объектов|Классы объектов использованной группы объектов|

#### Примеры


import {CodeSample} from './CodeSample.mdx'

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=ResolveASample"/>


<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=ResolveBSample"/>


<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=ResolveCSample"/>

**  
**
